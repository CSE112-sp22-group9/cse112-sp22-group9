/* eslint-disable */
const stringToByteArray$1 = function (r) {
        const n = [];
        let o = 0;
        for (let t = 0; t < r.length; t++) {
            let e = r.charCodeAt(t);
            e < 128
                ? (n[o++] = e)
                : (e < 2048
                      ? (n[o++] = (e >> 6) | 192)
                      : (55296 == (64512 & e) &&
                        t + 1 < r.length &&
                        56320 == (64512 & r.charCodeAt(t + 1))
                            ? ((e =
                                  65536 +
                                  ((1023 & e) << 10) +
                                  (1023 & r.charCodeAt(++t))),
                              (n[o++] = (e >> 18) | 240),
                              (n[o++] = ((e >> 12) & 63) | 128))
                            : (n[o++] = (e >> 12) | 224),
                        (n[o++] = ((e >> 6) & 63) | 128)),
                  (n[o++] = (63 & e) | 128));
        }
        return n;
    },
    byteArrayToString = function (e) {
        const t = [];
        let r = 0,
            n = 0;
        for (; r < e.length; ) {
            var o,
                i,
                a = e[r++];
            a < 128
                ? (t[n++] = String.fromCharCode(a))
                : 191 < a && a < 224
                ? ((o = e[r++]),
                  (t[n++] = String.fromCharCode(((31 & a) << 6) | (63 & o))))
                : 239 < a && a < 365
                ? ((i =
                      (((7 & a) << 18) |
                          ((63 & e[r++]) << 12) |
                          ((63 & e[r++]) << 6) |
                          (63 & e[r++])) -
                      65536),
                  (t[n++] = String.fromCharCode(55296 + (i >> 10))),
                  (t[n++] = String.fromCharCode(56320 + (1023 & i))))
                : ((o = e[r++]),
                  (i = e[r++]),
                  (t[n++] = String.fromCharCode(
                      ((15 & a) << 12) | ((63 & o) << 6) | (63 & i)
                  )));
        }
        return t.join('');
    },
    base64 = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE:
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + '+/=';
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + '-_.';
        },
        HAS_NATIVE_SUPPORT: 'function' == typeof atob,
        encodeByteArray(n, e) {
            if (!Array.isArray(n))
                throw Error('encodeByteArray takes an array as a parameter');
            this.init_();
            var o = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
            const i = [];
            for (let r = 0; r < n.length; r += 3) {
                var a = n[r],
                    s = r + 1 < n.length,
                    c = s ? n[r + 1] : 0,
                    l = r + 2 < n.length,
                    h = l ? n[r + 2] : 0;
                let e = ((15 & c) << 2) | (h >> 6),
                    t = 63 & h;
                l || ((t = 64), s || (e = 64)),
                    i.push(o[a >> 2], o[((3 & a) << 4) | (c >> 4)], o[e], o[t]);
            }
            return i.join('');
        },
        encodeString(e, t) {
            return this.HAS_NATIVE_SUPPORT && !t
                ? btoa(e)
                : this.encodeByteArray(stringToByteArray$1(e), t);
        },
        decodeString(e, t) {
            return this.HAS_NATIVE_SUPPORT && !t
                ? atob(e)
                : byteArrayToString(this.decodeStringToByteArray(e, t));
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            var r = e ? this.charToByteMapWebSafe_ : this.charToByteMap_;
            const n = [];
            for (let e = 0; e < t.length; ) {
                var o = r[t.charAt(e++)],
                    i = e < t.length ? r[t.charAt(e)] : 0;
                ++e;
                var a = e < t.length ? r[t.charAt(e)] : 64;
                ++e;
                var s = e < t.length ? r[t.charAt(e)] : 64;
                if ((++e, null == o || null == i || null == a || null == s))
                    throw Error();
                n.push((o << 2) | (i >> 4)),
                    64 !== a &&
                        (n.push(((i << 4) & 240) | (a >> 2)),
                        64 !== s && n.push(((a << 6) & 192) | s));
            }
            return n;
        },
        init_() {
            if (!this.byteToCharMap_) {
                (this.byteToCharMap_ = {}),
                    (this.charToByteMap_ = {}),
                    (this.byteToCharMapWebSafe_ = {}),
                    (this.charToByteMapWebSafe_ = {});
                for (let e = 0; e < this.ENCODED_VALS.length; e++)
                    (this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e)),
                        (this.charToByteMap_[this.byteToCharMap_[e]] = e),
                        (this.byteToCharMapWebSafe_[
                            e
                        ] = this.ENCODED_VALS_WEBSAFE.charAt(e)),
                        (this.charToByteMapWebSafe_[
                            this.byteToCharMapWebSafe_[e]
                        ] = e),
                        e >= this.ENCODED_VALS_BASE.length &&
                            ((this.charToByteMap_[
                                this.ENCODED_VALS_WEBSAFE.charAt(e)
                            ] = e),
                            (this.charToByteMapWebSafe_[
                                this.ENCODED_VALS.charAt(e)
                            ] = e));
            }
        },
    },
    base64Encode = function (e) {
        e = stringToByteArray$1(e);
        return base64.encodeByteArray(e, !0);
    };
class Deferred {
    constructor() {
        (this.reject = () => {}),
            (this.resolve = () => {}),
            (this.promise = new Promise((e, t) => {
                (this.resolve = e), (this.reject = t);
            }));
    }
    wrapCallback(r) {
        return (e, t) => {
            e ? this.reject(e) : this.resolve(t),
                'function' == typeof r &&
                    (this.promise.catch(() => {}),
                    1 === r.length ? r(e) : r(e, t));
        };
    }
}
function isIndexedDBAvailable() {
    return 'object' == typeof indexedDB;
}
function validateIndexedDBOpenable() {
    return new Promise((t, r) => {
        try {
            let e = !0;
            const n = 'validate-browser-context-for-indexeddb-analytics-module',
                o = self.indexedDB.open(n);
            (o.onsuccess = () => {
                o.result.close(), e || self.indexedDB.deleteDatabase(n), t(!0);
            }),
                (o.onupgradeneeded = () => {
                    e = !1;
                }),
                (o.onerror = () => {
                    var e;
                    r(
                        (null === (e = o.error) || void 0 === e
                            ? void 0
                            : e.message) || ''
                    );
                });
        } catch (e) {
            r(e);
        }
    });
}
const ERROR_NAME = 'FirebaseError';
class FirebaseError extends Error {
    constructor(e, t, r) {
        super(t),
            (this.code = e),
            (this.customData = r),
            (this.name = ERROR_NAME),
            Object.setPrototypeOf(this, FirebaseError.prototype),
            Error.captureStackTrace &&
                Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
}
class ErrorFactory {
    constructor(e, t, r) {
        (this.service = e), (this.serviceName = t), (this.errors = r);
    }
    create(e, ...t) {
        var r = t[0] || {},
            t = `${this.service}/${e}`,
            e = this.errors[e],
            e = e ? replaceTemplate(e, r) : 'Error',
            e = `${this.serviceName}: ${e} (${t}).`;
        return new FirebaseError(t, e, r);
    }
}
function replaceTemplate(e, n) {
    return e.replace(PATTERN, (e, t) => {
        var r = n[t];
        return null != r ? String(r) : `<${t}?>`;
    });
}
const PATTERN = /\{\$([^}]+)}/g;
function deepEqual(e, t) {
    if (e === t) return !0;
    const r = Object.keys(e),
        n = Object.keys(t);
    for (const a of r) {
        if (!n.includes(a)) return !1;
        var o = e[a],
            i = t[a];
        if (isObject(o) && isObject(i)) {
            if (!deepEqual(o, i)) return !1;
        } else if (o !== i) return !1;
    }
    for (const s of n) if (!r.includes(s)) return !1;
    return !0;
}
function isObject(e) {
    return null !== e && 'object' == typeof e;
}
class Component {
    constructor(e, t, r) {
        (this.name = e),
            (this.instanceFactory = t),
            (this.type = r),
            (this.multipleInstances = !1),
            (this.serviceProps = {}),
            (this.instantiationMode = 'LAZY'),
            (this.onInstanceCreated = null);
    }
    setInstantiationMode(e) {
        return (this.instantiationMode = e), this;
    }
    setMultipleInstances(e) {
        return (this.multipleInstances = e), this;
    }
    setServiceProps(e) {
        return (this.serviceProps = e), this;
    }
    setInstanceCreatedCallback(e) {
        return (this.onInstanceCreated = e), this;
    }
}
const DEFAULT_ENTRY_NAME$1 = '[DEFAULT]';
class Provider {
    constructor(e, t) {
        (this.name = e),
            (this.container = t),
            (this.component = null),
            (this.instances = new Map()),
            (this.instancesDeferred = new Map()),
            (this.instancesOptions = new Map()),
            (this.onInitCallbacks = new Map());
    }
    get(e) {
        e = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(e)) {
            const r = new Deferred();
            if (
                (this.instancesDeferred.set(e, r),
                this.isInitialized(e) || this.shouldAutoInitialize())
            )
                try {
                    var t = this.getOrInitializeService({
                        instanceIdentifier: e,
                    });
                    t && r.resolve(t);
                } catch (e) {}
        }
        return this.instancesDeferred.get(e).promise;
    }
    getImmediate(t) {
        var e = this.normalizeInstanceIdentifier(
                null == t ? void 0 : t.identifier
            ),
            t =
                null !== (t = null == t ? void 0 : t.optional) &&
                void 0 !== t &&
                t;
        if (!this.isInitialized(e) && !this.shouldAutoInitialize()) {
            if (t) return null;
            throw Error(`Service ${this.name} is not available`);
        }
        try {
            return this.getOrInitializeService({ instanceIdentifier: e });
        } catch (e) {
            if (t) return null;
            throw e;
        }
    }
    getComponent() {
        return this.component;
    }
    setComponent(e) {
        if (e.name !== this.name)
            throw Error(
                `Mismatching Component ${e.name} for Provider ${this.name}.`
            );
        if (this.component)
            throw Error(`Component for ${this.name} has already been provided`);
        if (((this.component = e), this.shouldAutoInitialize())) {
            if (isComponentEager(e))
                try {
                    this.getOrInitializeService({
                        instanceIdentifier: DEFAULT_ENTRY_NAME$1,
                    });
                } catch (e) {}
            for (var [t, r] of this.instancesDeferred.entries()) {
                t = this.normalizeInstanceIdentifier(t);
                try {
                    var n = this.getOrInitializeService({
                        instanceIdentifier: t,
                    });
                    r.resolve(n);
                } catch (e) {}
            }
        }
    }
    clearInstance(e = DEFAULT_ENTRY_NAME$1) {
        this.instancesDeferred.delete(e),
            this.instancesOptions.delete(e),
            this.instances.delete(e);
    }
    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([
            ...e.filter((e) => 'INTERNAL' in e).map((e) => e.INTERNAL.delete()),
            ...e.filter((e) => '_delete' in e).map((e) => e._delete()),
        ]);
    }
    isComponentSet() {
        return null != this.component;
    }
    isInitialized(e = DEFAULT_ENTRY_NAME$1) {
        return this.instances.has(e);
    }
    getOptions(e = DEFAULT_ENTRY_NAME$1) {
        return this.instancesOptions.get(e) || {};
    }
    initialize(e = {}) {
        var { options: t = {} } = e,
            r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(r))
            throw Error(`${this.name}(${r}) has already been initialized`);
        if (!this.isComponentSet())
            throw Error(`Component ${this.name} has not been registered yet`);
        var n,
            o,
            i = this.getOrInitializeService({
                instanceIdentifier: r,
                options: t,
            });
        for ([n, o] of this.instancesDeferred.entries())
            r === this.normalizeInstanceIdentifier(n) && o.resolve(i);
        return i;
    }
    onInit(e, t) {
        var r = this.normalizeInstanceIdentifier(t);
        const n =
            null !== (t = this.onInitCallbacks.get(r)) && void 0 !== t
                ? t
                : new Set();
        n.add(e), this.onInitCallbacks.set(r, n);
        t = this.instances.get(r);
        return (
            t && e(t, r),
            () => {
                n.delete(e);
            }
        );
    }
    invokeOnInitCallbacks(e, t) {
        var r = this.onInitCallbacks.get(t);
        if (r)
            for (const n of r)
                try {
                    n(e, t);
                } catch (e) {}
    }
    getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
        let r = this.instances.get(e);
        if (
            !r &&
            this.component &&
            ((r = this.component.instanceFactory(this.container, {
                instanceIdentifier: normalizeIdentifierForFactory(e),
                options: t,
            })),
            this.instances.set(e, r),
            this.instancesOptions.set(e, t),
            this.invokeOnInitCallbacks(r, e),
            this.component.onInstanceCreated)
        )
            try {
                this.component.onInstanceCreated(this.container, e, r);
            } catch (e) {}
        return r || null;
    }
    normalizeInstanceIdentifier(e = DEFAULT_ENTRY_NAME$1) {
        return !this.component || this.component.multipleInstances
            ? e
            : DEFAULT_ENTRY_NAME$1;
    }
    shouldAutoInitialize() {
        return (
            !!this.component && 'EXPLICIT' !== this.component.instantiationMode
        );
    }
}
function normalizeIdentifierForFactory(e) {
    return e === DEFAULT_ENTRY_NAME$1 ? void 0 : e;
}
function isComponentEager(e) {
    return 'EAGER' === e.instantiationMode;
}
class ComponentContainer {
    constructor(e) {
        (this.name = e), (this.providers = new Map());
    }
    addComponent(e) {
        const t = this.getProvider(e.name);
        if (t.isComponentSet())
            throw new Error(
                `Component ${e.name} has already been registered with ${this.name}`
            );
        t.setComponent(e);
    }
    addOrOverwriteComponent(e) {
        const t = this.getProvider(e.name);
        t.isComponentSet() && this.providers.delete(e.name),
            this.addComponent(e);
    }
    getProvider(e) {
        if (this.providers.has(e)) return this.providers.get(e);
        var t = new Provider(e, this);
        return this.providers.set(e, t), t;
    }
    getProviders() {
        return Array.from(this.providers.values());
    }
}
const instances = [];
var LogLevel;
!(function (e) {
    (e[(e.DEBUG = 0)] = 'DEBUG'),
        (e[(e.VERBOSE = 1)] = 'VERBOSE'),
        (e[(e.INFO = 2)] = 'INFO'),
        (e[(e.WARN = 3)] = 'WARN'),
        (e[(e.ERROR = 4)] = 'ERROR'),
        (e[(e.SILENT = 5)] = 'SILENT');
})((LogLevel = LogLevel || {}));
const levelStringToEnum = {
        debug: LogLevel.DEBUG,
        verbose: LogLevel.VERBOSE,
        info: LogLevel.INFO,
        warn: LogLevel.WARN,
        error: LogLevel.ERROR,
        silent: LogLevel.SILENT,
    },
    defaultLogLevel = LogLevel.INFO,
    ConsoleMethod = {
        [LogLevel.DEBUG]: 'log',
        [LogLevel.VERBOSE]: 'log',
        [LogLevel.INFO]: 'info',
        [LogLevel.WARN]: 'warn',
        [LogLevel.ERROR]: 'error',
    },
    defaultLogHandler = (e, t, ...r) => {
        if (!(t < e.logLevel)) {
            var n = new Date().toISOString(),
                o = ConsoleMethod[t];
            if (!o)
                throw new Error(
                    `Attempted to log a message with an invalid logType (value: ${t})`
                );
            console[o](`[${n}]  ${e.name}:`, ...r);
        }
    };
class Logger {
    constructor(e) {
        (this.name = e),
            (this._logLevel = defaultLogLevel),
            (this._logHandler = defaultLogHandler),
            (this._userLogHandler = null),
            instances.push(this);
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(e) {
        if (!(e in LogLevel))
            throw new TypeError(
                `Invalid value "${e}" assigned to \`logLevel\``
            );
        this._logLevel = e;
    }
    setLogLevel(e) {
        this._logLevel = 'string' == typeof e ? levelStringToEnum[e] : e;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(e) {
        if ('function' != typeof e)
            throw new TypeError(
                'Value assigned to `logHandler` must be a function'
            );
        this._logHandler = e;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(e) {
        this._userLogHandler = e;
    }
    debug(...e) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.DEBUG, ...e),
            this._logHandler(this, LogLevel.DEBUG, ...e);
    }
    log(...e) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...e),
            this._logHandler(this, LogLevel.VERBOSE, ...e);
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...e),
            this._logHandler(this, LogLevel.INFO, ...e);
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...e),
            this._logHandler(this, LogLevel.WARN, ...e);
    }
    error(...e) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.ERROR, ...e),
            this._logHandler(this, LogLevel.ERROR, ...e);
    }
}
function setLogLevel$1(t) {
    instances.forEach((e) => {
        e.setLogLevel(t);
    });
}
function setUserLogHandler(i, e) {
    for (const t of instances) {
        let o = null;
        e && e.level && (o = levelStringToEnum[e.level]),
            (t.userLogHandler =
                null === i
                    ? null
                    : (e, t, ...r) => {
                          var n = r
                              .map((e) => {
                                  if (null == e) return null;
                                  if ('string' == typeof e) return e;
                                  if (
                                      'number' == typeof e ||
                                      'boolean' == typeof e
                                  )
                                      return e.toString();
                                  if (e instanceof Error) return e.message;
                                  try {
                                      return JSON.stringify(e);
                                  } catch (e) {
                                      return null;
                                  }
                              })
                              .filter((e) => e)
                              .join(' ');
                          t >= (null !== o && void 0 !== o ? o : e.logLevel) &&
                              i({
                                  level: LogLevel[t].toLowerCase(),
                                  message: n,
                                  args: r,
                                  type: e.name,
                              });
                      });
    }
}
function toArray(e) {
    return Array.prototype.slice.call(e);
}
function promisifyRequest(r) {
    return new Promise(function (e, t) {
        (r.onsuccess = function () {
            e(r.result);
        }),
            (r.onerror = function () {
                t(r.error);
            });
    });
}
function promisifyRequestCall(r, n, o) {
    var i,
        e = new Promise(function (e, t) {
            promisifyRequest((i = r[n].apply(r, o))).then(e, t);
        });
    return (e.request = i), e;
}
function promisifyCursorRequestCall(e, t, r) {
    var n = promisifyRequestCall(e, t, r);
    return n.then(function (e) {
        if (e) return new Cursor(e, n.request);
    });
}
function proxyProperties(e, r, t) {
    t.forEach(function (t) {
        Object.defineProperty(e.prototype, t, {
            get: function () {
                return this[r][t];
            },
            set: function (e) {
                this[r][t] = e;
            },
        });
    });
}
function proxyRequestMethods(t, r, n, e) {
    e.forEach(function (e) {
        e in n.prototype &&
            (t.prototype[e] = function () {
                return promisifyRequestCall(this[r], e, arguments);
            });
    });
}
function proxyMethods(t, r, n, e) {
    e.forEach(function (e) {
        e in n.prototype &&
            (t.prototype[e] = function () {
                return this[r][e].apply(this[r], arguments);
            });
    });
}
function proxyCursorRequestMethods(t, r, n, e) {
    e.forEach(function (e) {
        e in n.prototype &&
            (t.prototype[e] = function () {
                return promisifyCursorRequestCall(this[r], e, arguments);
            });
    });
}
function Index(e) {
    this._index = e;
}
function Cursor(e, t) {
    (this._cursor = e), (this._request = t);
}
function ObjectStore(e) {
    this._store = e;
}
function Transaction(r) {
    (this._tx = r),
        (this.complete = new Promise(function (e, t) {
            (r.oncomplete = function () {
                e();
            }),
                (r.onerror = function () {
                    t(r.error);
                }),
                (r.onabort = function () {
                    t(r.error);
                });
        }));
}
function UpgradeDB(e, t, r) {
    (this._db = e),
        (this.oldVersion = t),
        (this.transaction = new Transaction(r));
}
function DB(e) {
    this._db = e;
}
function openDb(e, t, r) {
    var t = promisifyRequestCall(indexedDB, 'open', [e, t]),
        n = t.request;
    return (
        n &&
            (n.onupgradeneeded = function (e) {
                r && r(new UpgradeDB(n.result, e.oldVersion, n.transaction));
            }),
        t.then(function (e) {
            return new DB(e);
        })
    );
}
proxyProperties(Index, '_index', ['name', 'keyPath', 'multiEntry', 'unique']),
    proxyRequestMethods(Index, '_index', IDBIndex, [
        'get',
        'getKey',
        'getAll',
        'getAllKeys',
        'count',
    ]),
    proxyCursorRequestMethods(Index, '_index', IDBIndex, [
        'openCursor',
        'openKeyCursor',
    ]),
    proxyProperties(Cursor, '_cursor', [
        'direction',
        'key',
        'primaryKey',
        'value',
    ]),
    proxyRequestMethods(Cursor, '_cursor', IDBCursor, ['update', 'delete']),
    ['advance', 'continue', 'continuePrimaryKey'].forEach(function (r) {
        r in IDBCursor.prototype &&
            (Cursor.prototype[r] = function () {
                var t = this,
                    e = arguments;
                return Promise.resolve().then(function () {
                    return (
                        t._cursor[r].apply(t._cursor, e),
                        promisifyRequest(t._request).then(function (e) {
                            if (e) return new Cursor(e, t._request);
                        })
                    );
                });
            });
    }),
    (ObjectStore.prototype.createIndex = function () {
        return new Index(this._store.createIndex.apply(this._store, arguments));
    }),
    (ObjectStore.prototype.index = function () {
        return new Index(this._store.index.apply(this._store, arguments));
    }),
    proxyProperties(ObjectStore, '_store', [
        'name',
        'keyPath',
        'indexNames',
        'autoIncrement',
    ]),
    proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
        'put',
        'add',
        'delete',
        'clear',
        'get',
        'getAll',
        'getKey',
        'getAllKeys',
        'count',
    ]),
    proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
        'openCursor',
        'openKeyCursor',
    ]),
    proxyMethods(ObjectStore, '_store', IDBObjectStore, ['deleteIndex']),
    (Transaction.prototype.objectStore = function () {
        return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
    }),
    proxyProperties(Transaction, '_tx', ['objectStoreNames', 'mode']),
    proxyMethods(Transaction, '_tx', IDBTransaction, ['abort']),
    (UpgradeDB.prototype.createObjectStore = function () {
        return new ObjectStore(
            this._db.createObjectStore.apply(this._db, arguments)
        );
    }),
    proxyProperties(UpgradeDB, '_db', ['name', 'version', 'objectStoreNames']),
    proxyMethods(UpgradeDB, '_db', IDBDatabase, ['deleteObjectStore', 'close']),
    (DB.prototype.transaction = function () {
        return new Transaction(this._db.transaction.apply(this._db, arguments));
    }),
    proxyProperties(DB, '_db', ['name', 'version', 'objectStoreNames']),
    proxyMethods(DB, '_db', IDBDatabase, ['close']),
    ['openCursor', 'openKeyCursor'].forEach(function (o) {
        [ObjectStore, Index].forEach(function (e) {
            o in e.prototype &&
                (e.prototype[o.replace('open', 'iterate')] = function () {
                    var e = toArray(arguments),
                        t = e[e.length - 1],
                        r = this._store || this._index,
                        n = r[o].apply(r, e.slice(0, -1));
                    n.onsuccess = function () {
                        t(n.result);
                    };
                });
        });
    }),
    [Index, ObjectStore].forEach(function (e) {
        e.prototype.getAll ||
            (e.prototype.getAll = function (e, r) {
                var n = this,
                    o = [];
                return new Promise(function (t) {
                    n.iterateCursor(e, function (e) {
                        e
                            ? (o.push(e.value),
                              void 0 === r || o.length != r
                                  ? e.continue()
                                  : t(o))
                            : t(o);
                    });
                });
            });
    });
class PlatformLoggerServiceImpl {
    constructor(e) {
        this.container = e;
    }
    getPlatformInfoString() {
        const e = this.container.getProviders();
        return e
            .map((e) => {
                if (isVersionServiceProvider(e)) {
                    e = e.getImmediate();
                    return `${e.library}/${e.version}`;
                }
                return null;
            })
            .filter((e) => e)
            .join(' ');
    }
}
function isVersionServiceProvider(e) {
    e = e.getComponent();
    return 'VERSION' === (null == e ? void 0 : e.type);
}
const name$o = 'https://www.gstatic.com/firebasejs/9.6.8/firebase-app.js',
    version$1 = '0.7.18',
    logger = new Logger(
        'https://www.gstatic.com/firebasejs/9.6.8/firebase-app.js'
    ),
    name$n = 'https://www.gstatic.com/firebasejs/9.6.8/firebase-app.js-compat',
    name$m = '@firebase/analytics-compat',
    name$l = '@firebase/analytics',
    name$k =
        'https://www.gstatic.com/firebasejs/9.6.8/firebase-app.js-check-compat',
    name$j = 'https://www.gstatic.com/firebasejs/9.6.8/firebase-app.js-check',
    name$i = '@firebase/auth',
    name$h = '@firebase/auth-compat',
    name$g = '@firebase/database',
    name$f = '@firebase/database-compat',
    name$e = '@firebase/functions',
    name$d = '@firebase/functions-compat',
    name$c = '@firebase/installations',
    name$b = '@firebase/installations-compat',
    name$a = '@firebase/messaging',
    name$9 = '@firebase/messaging-compat',
    name$8 = '@firebase/performance',
    name$7 = '@firebase/performance-compat',
    name$6 = '@firebase/remote-config',
    name$5 = '@firebase/remote-config-compat',
    name$4 = '@firebase/storage',
    name$3 = '@firebase/storage-compat',
    name$2 = '@firebase/firestore',
    name$1 = '@firebase/firestore-compat',
    name$p = 'firebase',
    version$2 = '9.6.8',
    DEFAULT_ENTRY_NAME = '[DEFAULT]',
    PLATFORM_LOG_STRING = {
        [name$o]: 'fire-core',
        [name$n]: 'fire-core-compat',
        [name$l]: 'fire-analytics',
        [name$m]: 'fire-analytics-compat',
        [name$j]: 'fire-app-check',
        [name$k]: 'fire-app-check-compat',
        [name$i]: 'fire-auth',
        [name$h]: 'fire-auth-compat',
        [name$g]: 'fire-rtdb',
        [name$f]: 'fire-rtdb-compat',
        [name$e]: 'fire-fn',
        [name$d]: 'fire-fn-compat',
        [name$c]: 'fire-iid',
        [name$b]: 'fire-iid-compat',
        [name$a]: 'fire-fcm',
        [name$9]: 'fire-fcm-compat',
        [name$8]: 'fire-perf',
        [name$7]: 'fire-perf-compat',
        [name$6]: 'fire-rc',
        [name$5]: 'fire-rc-compat',
        [name$4]: 'fire-gcs',
        [name$3]: 'fire-gcs-compat',
        [name$2]: 'fire-fst',
        [name$1]: 'fire-fst-compat',
        'fire-js': 'fire-js',
        [name$p]: 'fire-js-all',
    },
    _apps = new Map(),
    _components = new Map();
function _addComponent(t, r) {
    try {
        t.container.addComponent(r);
    } catch (e) {
        logger.debug(
            `Component ${r.name} failed to register with FirebaseApp ${t.name}`,
            e
        );
    }
}
function _addOrOverwriteComponent(e, t) {
    e.container.addOrOverwriteComponent(t);
}
function _registerComponent(e) {
    var t = e.name;
    if (_components.has(t))
        return (
            logger.debug(
                `There were multiple attempts to register component ${t}.`
            ),
            !1
        );
    _components.set(t, e);
    for (const r of _apps.values()) _addComponent(r, e);
    return !0;
}
function _getProvider(e, t) {
    const r = e.container
        .getProvider('heartbeat')
        .getImmediate({ optional: !0 });
    return r && r.triggerHeartbeat(), e.container.getProvider(t);
}
function _removeServiceInstance(e, t, r = DEFAULT_ENTRY_NAME) {
    _getProvider(e, t).clearInstance(r);
}
function _clearComponents() {
    _components.clear();
}
const ERRORS = {
        'no-app':
            "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
        'bad-app-name': "Illegal App name: '{$appName}",
        'duplicate-app':
            "Firebase App named '{$appName}' already exists with different options or config",
        'app-deleted': "Firebase App named '{$appName}' already deleted",
        'invalid-app-argument':
            'firebase.{$appName}() takes either no argument or a Firebase App instance.',
        'invalid-log-argument':
            'First argument to `onLog` must be null or a function.',
        'storage-open':
            'Error thrown when opening storage. Original error: {$originalErrorMessage}.',
        'storage-get':
            'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',
        'storage-set':
            'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',
        'storage-delete':
            'Error thrown when deleting from storage. Original error: {$originalErrorMessage}.',
    },
    ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);
class FirebaseAppImpl {
    constructor(e, t, r) {
        (this._isDeleted = !1),
            (this._options = Object.assign({}, e)),
            (this._config = Object.assign({}, t)),
            (this._name = t.name),
            (this._automaticDataCollectionEnabled =
                t.automaticDataCollectionEnabled),
            (this._container = r),
            this.container.addComponent(
                new Component('app', () => this, 'PUBLIC')
            );
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(), this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(), (this._automaticDataCollectionEnabled = e);
    }
    get name() {
        return this.checkDestroyed(), this._name;
    }
    get options() {
        return this.checkDestroyed(), this._options;
    }
    get config() {
        return this.checkDestroyed(), this._config;
    }
    get container() {
        return this._container;
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(e) {
        this._isDeleted = e;
    }
    checkDestroyed() {
        if (this.isDeleted)
            throw ERROR_FACTORY.create('app-deleted', { appName: this._name });
    }
}
const SDK_VERSION = version$2;
function initializeApp(e, t = {}) {
    if ('object' != typeof t) {
        const n = t;
        t = { name: n };
    }
    var r = Object.assign(
        { name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: !1 },
        t
    );
    const n = r.name;
    if ('string' != typeof n || !n)
        throw ERROR_FACTORY.create('bad-app-name', { appName: String(n) });
    t = _apps.get(n);
    if (t) {
        if (deepEqual(e, t.options) && deepEqual(r, t.config)) return t;
        throw ERROR_FACTORY.create('duplicate-app', { appName: n });
    }
    const o = new ComponentContainer(n);
    for (const i of _components.values()) o.addComponent(i);
    r = new FirebaseAppImpl(e, r, o);
    return _apps.set(n, r), r;
}
function getApp(e = DEFAULT_ENTRY_NAME) {
    var t = _apps.get(e);
    if (!t) throw ERROR_FACTORY.create('no-app', { appName: e });
    return t;
}
function getApps() {
    return Array.from(_apps.values());
}
async function deleteApp(e) {
    var t = e.name;
    _apps.has(t) &&
        (_apps.delete(t),
        await Promise.all(e.container.getProviders().map((e) => e.delete())),
        (e.isDeleted = !0));
}
function registerVersion(e, t, r) {
    var n;
    let o = null !== (n = PLATFORM_LOG_STRING[e]) && void 0 !== n ? n : e;
    r && (o += `-${r}`);
    (e = o.match(/\s|\//)), (r = t.match(/\s|\//));
    if (e || r) {
        const i = [`Unable to register library "${o}" with version "${t}":`];
        return (
            e &&
                i.push(
                    `library name "${o}" contains illegal characters (whitespace or "/")`
                ),
            e && r && i.push('and'),
            r &&
                i.push(
                    `version name "${t}" contains illegal characters (whitespace or "/")`
                ),
            void logger.warn(i.join(' '))
        );
    }
    _registerComponent(
        new Component(
            `${o}-version`,
            () => ({ library: o, version: t }),
            'VERSION'
        )
    );
}
function onLog(e, t) {
    if (null !== e && 'function' != typeof e)
        throw ERROR_FACTORY.create('invalid-log-argument');
    setUserLogHandler(e, t);
}
function setLogLevel(e) {
    setLogLevel$1(e);
}
const DB_NAME = 'firebase-heartbeat-database',
    DB_VERSION = 1,
    STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() {
    return (
        (dbPromise =
            dbPromise ||
            openDb(DB_NAME, DB_VERSION, (e) => {
                0 === e.oldVersion && e.createObjectStore(STORE_NAME);
            }).catch((e) => {
                throw ERROR_FACTORY.create('storage-open', {
                    originalErrorMessage: e.message,
                });
            })),
        dbPromise
    );
}
async function readHeartbeatsFromIndexedDB(e) {
    try {
        const t = await getDbPromise();
        return t
            .transaction(STORE_NAME)
            .objectStore(STORE_NAME)
            .get(computeKey(e));
    } catch (e) {
        throw ERROR_FACTORY.create('storage-get', {
            originalErrorMessage: e.message,
        });
    }
}
async function writeHeartbeatsToIndexedDB(e, t) {
    try {
        const r = await getDbPromise(),
            n = r.transaction(STORE_NAME, 'readwrite'),
            o = n.objectStore(STORE_NAME);
        return await o.put(t, computeKey(e)), n.complete;
    } catch (e) {
        throw ERROR_FACTORY.create('storage-set', {
            originalErrorMessage: e.message,
        });
    }
}
async function deleteHeartbeatsFromIndexedDB(e) {
    try {
        const t = await getDbPromise(),
            r = t.transaction(STORE_NAME, 'readwrite');
        return (
            await r.objectStore(STORE_NAME).delete(computeKey(e)), r.complete
        );
    } catch (e) {
        throw ERROR_FACTORY.create('storage-delete', {
            originalErrorMessage: e.message,
        });
    }
}
function computeKey(e) {
    return `${e.name}!${e.options.appId}`;
}
const MAX_HEADER_BYTES = 1024,
    STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 2592e6;
class HeartbeatServiceImpl {
    constructor(e) {
        (this.container = e), (this._heartbeatsCache = null);
        e = this.container.getProvider('app').getImmediate();
        (this._storage = new HeartbeatStorageImpl(e)),
            (this._heartbeatsCachePromise = this._storage
                .read()
                .then((e) => (this._heartbeatsCache = e)));
    }
    async triggerHeartbeat() {
        const e = this.container.getProvider('platform-logger').getImmediate();
        var t = e.getPlatformInfoString();
        const r = getUTCDateString();
        if (
            (null === this._heartbeatsCache &&
                (this._heartbeatsCache = await this._heartbeatsCachePromise),
            !this._heartbeatsCache.some((e) => e.date === r))
        )
            return (
                this._heartbeatsCache.push({ date: r, userAgent: t }),
                (this._heartbeatsCache = this._heartbeatsCache.filter((e) => {
                    e = new Date(e.date).valueOf();
                    return (
                        Date.now() - e <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS
                    );
                })),
                this._storage.overwrite(this._heartbeatsCache)
            );
    }
    async getHeartbeatsHeader() {
        if (
            (null === this._heartbeatsCache &&
                (await this._heartbeatsCachePromise),
            null === this._heartbeatsCache)
        )
            return '';
        var {
                heartbeatsToSend: e,
                unsentEntries: t,
            } = extractHeartbeatsForHeader(this._heartbeatsCache),
            e = base64Encode(JSON.stringify({ version: 2, heartbeats: e }));
        return (
            0 < t.length
                ? ((this._heartbeatsCache = t),
                  await this._storage.overwrite(this._heartbeatsCache))
                : ((this._heartbeatsCache = null), this._storage.deleteAll()),
            e
        );
    }
}
function getUTCDateString() {
    const e = new Date();
    return e.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(e, t = MAX_HEADER_BYTES) {
    const r = [];
    let n = e.slice();
    for (const o of e) {
        const i = r.find((e) => e.userAgent === o.userAgent);
        if (i) {
            if ((i.dates.push(o.date), countBytes(r) > t)) {
                i.dates.pop();
                break;
            }
        } else if (
            (r.push({ userAgent: o.userAgent, dates: [o.date] }),
            countBytes(r) > t)
        ) {
            r.pop();
            break;
        }
        n = n.slice(1);
    }
    return { heartbeatsToSend: r, unsentEntries: n };
}
class HeartbeatStorageImpl {
    constructor(e) {
        (this.app = e),
            (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
    }
    async runIndexedDBEnvironmentCheck() {
        return (
            !!isIndexedDBAvailable() &&
            validateIndexedDBOpenable()
                .then(() => !0)
                .catch(() => !1)
        );
    }
    async read() {
        if (await this._canUseIndexedDBPromise) {
            var e = await readHeartbeatsFromIndexedDB(this.app);
            return (null == e ? void 0 : e.heartbeats) || [];
        }
        return [];
    }
    async overwrite(e) {
        if (await this._canUseIndexedDBPromise)
            return writeHeartbeatsToIndexedDB(this.app, { heartbeats: e });
    }
    async add(e) {
        if (await this._canUseIndexedDBPromise) {
            var t = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                heartbeats: [...t, ...e],
            });
        }
    }
    async delete(t) {
        if (await this._canUseIndexedDBPromise) {
            const e = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                heartbeats: e.filter((e) => !t.includes(e)),
            });
        }
    }
    async deleteAll() {
        if (await this._canUseIndexedDBPromise)
            return deleteHeartbeatsFromIndexedDB(this.app);
    }
}
function countBytes(e) {
    return base64Encode(JSON.stringify({ version: 2, heartbeats: e })).length;
}
function registerCoreComponents(e) {
    _registerComponent(
        new Component(
            'platform-logger',
            (e) => new PlatformLoggerServiceImpl(e),
            'PRIVATE'
        )
    ),
        _registerComponent(
            new Component(
                'heartbeat',
                (e) => new HeartbeatServiceImpl(e),
                'PRIVATE'
            )
        ),
        registerVersion(name$o, version$1, e),
        registerVersion(name$o, version$1, 'esm2017'),
        registerVersion('fire-js', '');
}
registerCoreComponents('');
var name = 'firebase',
    version = '9.6.8';
registerVersion(name, version, 'cdn');
export {
    FirebaseError,
    SDK_VERSION,
    DEFAULT_ENTRY_NAME as _DEFAULT_ENTRY_NAME,
    _addComponent,
    _addOrOverwriteComponent,
    _apps,
    _clearComponents,
    _components,
    _getProvider,
    _registerComponent,
    _removeServiceInstance,
    deleteApp,
    getApp,
    getApps,
    initializeApp,
    onLog,
    registerVersion,
    setLogLevel,
};
